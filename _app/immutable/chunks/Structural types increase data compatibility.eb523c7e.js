import{s as es,C as P,N as O,f as y,a as d,I as L,e as S,g as D,u,c as k,K as M,i,d as p,A as ts}from"./scheduler.e9e6880c.js";import{S as ls,i as ns,b as G,d as J,m as K,a as R,t as X,e as z}from"./index.ebf47752.js";import{g as is,a as Y}from"./spread.8a54911c.js";import{M as ps}from"./MDSveXNoteLayout.71f8c5f7.js";import{T as os}from"./Table.1e2c9b0c.js";function rs(h){let a,r="<tr><th></th> <th>Nominal</th> <th>Structural</th></tr>",o,n,t="<tr><td>Languages</td> <td>C, C++, Java, C#</td> <td>TypeScript, Go</td></tr> <tr><td>Type compatibility requirements</td> <td>Structure and name</td> <td>Structure</td></tr> <tr><td>Specificity</td> <td>Strict</td> <td>Flexible</td></tr>";return{c(){a=y("thead"),a.innerHTML=r,o=d(),n=y("tbody"),n.innerHTML=t},l(e){a=D(e,"THEAD",{["data-svelte-h"]:!0}),u(a)!=="svelte-rsxkvl"&&(a.innerHTML=r),o=k(e),n=D(e,"TBODY",{["data-svelte-h"]:!0}),u(n)!=="svelte-1m6m8v6"&&(n.innerHTML=t)},m(e,c){i(e,a,c),i(e,o,c),i(e,n,c)},p:ts,d(e){e&&(p(a),p(o),p(n))}}}function cs(h){let a,r="Typescript uses an approach to types called “structural typing”. Structural types are compatible if they share the same structure: the same named members and those members have the same types. This differs from languages such as C &amp; C++ which use an approach called “nominal typing.” Nominal types are only equivalent if they share the same structure <strong>and name</strong>. Here’s a quick reference:",o,n,t,e,c="I find it easiest to understand how structural types work with code examples:",T,b,Q=`<pre class="shiki shiki-themes github-light slack-dark" style="background-color:#fff;--shiki-dark-bg:#222222;color:#24292e;--shiki-dark:#E6E6E6" tabindex="0"><code><span class="line"><span style="color:#D73A49;--shiki-dark:#569CD6">type</span><span style="color:#6F42C1;--shiki-dark:#4EC9B0"> A</span><span style="color:#D73A49;--shiki-dark:#D4D4D4"> =</span><span style="color:#24292E;--shiki-dark:#E6E6E6"> &#123; </span><span style="color:#E36209;--shiki-dark:#9CDCFE">a</span><span style="color:#D73A49;--shiki-dark:#D4D4D4">:</span><span style="color:#005CC5;--shiki-dark:#4EC9B0"> number</span><span style="color:#24292E;--shiki-dark:#E6E6E6"> &#125;;</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#569CD6">type</span><span style="color:#6F42C1;--shiki-dark:#4EC9B0"> B</span><span style="color:#D73A49;--shiki-dark:#D4D4D4"> =</span><span style="color:#24292E;--shiki-dark:#E6E6E6"> &#123; </span><span style="color:#E36209;--shiki-dark:#9CDCFE">a</span><span style="color:#D73A49;--shiki-dark:#D4D4D4">:</span><span style="color:#005CC5;--shiki-dark:#4EC9B0"> number</span><span style="color:#24292E;--shiki-dark:#E6E6E6">, </span><span style="color:#E36209;--shiki-dark:#9CDCFE">b</span><span style="color:#D73A49;--shiki-dark:#D4D4D4">:</span><span style="color:#005CC5;--shiki-dark:#4EC9B0"> string</span><span style="color:#24292E;--shiki-dark:#E6E6E6"> &#125;;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A9955">// &#96;a1&#96; is explicitly typed as an &#96;A&#96; object</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#569CD6">let</span><span style="color:#24292E;--shiki-dark:#9CDCFE"> a1</span><span style="color:#D73A49;--shiki-dark:#D4D4D4">:</span><span style="color:#6F42C1;--shiki-dark:#4EC9B0"> A</span><span style="color:#D73A49;--shiki-dark:#D4D4D4"> =</span><span style="color:#24292E;--shiki-dark:#E6E6E6"> &#123; </span><span style="color:#24292E;--shiki-dark:#9CDCFE">a:</span><span style="color:#005CC5;--shiki-dark:#B5CEA8"> 123</span><span style="color:#24292E;--shiki-dark:#E6E6E6"> &#125;;</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A9955">// &#96;a2&#96; is not explicitly typed as &#96;A&#96;...</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#569CD6">let</span><span style="color:#24292E;--shiki-dark:#9CDCFE"> a2</span><span style="color:#D73A49;--shiki-dark:#D4D4D4"> =</span><span style="color:#24292E;--shiki-dark:#E6E6E6"> &#123; </span><span style="color:#24292E;--shiki-dark:#9CDCFE">a:</span><span style="color:#005CC5;--shiki-dark:#B5CEA8"> 321</span><span style="color:#24292E;--shiki-dark:#E6E6E6"> &#125;;</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A9955">// But its structure matches,</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A9955">// so it can be assigned to a type &#96;A&#96; object</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#9CDCFE">a1</span><span style="color:#D73A49;--shiki-dark:#D4D4D4"> =</span><span style="color:#24292E;--shiki-dark:#9CDCFE"> a2</span><span style="color:#24292E;--shiki-dark:#E6E6E6">; </span><span style="color:#6A737D;--shiki-dark:#6A9955">// Valid</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A9955">// &#96;b&#96; is explicitly typed as a &#96;B&#96; object</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#569CD6">let</span><span style="color:#24292E;--shiki-dark:#9CDCFE"> b</span><span style="color:#D73A49;--shiki-dark:#D4D4D4">:</span><span style="color:#6F42C1;--shiki-dark:#4EC9B0"> B</span><span style="color:#D73A49;--shiki-dark:#D4D4D4"> =</span><span style="color:#24292E;--shiki-dark:#E6E6E6"> &#123;</span><span style="color:#24292E;--shiki-dark:#9CDCFE">a:</span><span style="color:#005CC5;--shiki-dark:#B5CEA8"> 135</span><span style="color:#24292E;--shiki-dark:#E6E6E6">, </span><span style="color:#24292E;--shiki-dark:#9CDCFE">b:</span><span style="color:#032F62;--shiki-dark:#CE9178"> "abc"</span><span style="color:#24292E;--shiki-dark:#E6E6E6">&#125;;</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A9955">// &#96;b&#96; can be assigned to an &#96;A&#96; object </span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A9955">// because it is a superset of the structure of A</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#9CDCFE">a2</span><span style="color:#D73A49;--shiki-dark:#D4D4D4"> =</span><span style="color:#24292E;--shiki-dark:#9CDCFE"> b</span><span style="color:#24292E;--shiki-dark:#E6E6E6">; </span><span style="color:#6A737D;--shiki-dark:#6A9955">// Valid</span></span></code></pre>`,A,_,W=`<pre class="code-copy-target hidden">type A = &#123; a: number &#125;;
type B = &#123; a: number, b: string &#125;;

// &#96;a1&#96; is explicitly typed as an &#96;A&#96; object
let a1: A = &#123; a: 123 &#125;;
// &#96;a2&#96; is not explicitly typed as &#96;A&#96;...
let a2 = &#123; a: 321 &#125;;
// But its structure matches,
// so it can be assigned to a type &#96;A&#96; object
a1 = a2; // Valid

// &#96;b&#96; is explicitly typed as a &#96;B&#96; object
let b: B = &#123;a: 135, b: "abc"&#125;;
// &#96;b&#96; can be assigned to an &#96;A&#96; object 
// because it is a superset of the structure of A
a2 = b; // Valid</pre>`,g,C,j="This approach is really convenient on the web where it’s common for data to come from external APIs; they may change the data provided. Structural typing makes it easy to handle extra data. In the <code>a2 = b</code> example above, the extra data on <code>b</code> is “sliced” off, narrowing it to an <code>A</code> object. The extra field on <code>B</code> doesn’t cause any issues! This makes it easy to opt-in to using additional data on a type when I’m ready, and to continue working until then.",x,E,U="TypeScript type compatibility can <em>reduce clarity</em> that a developer could otherwise provide using a named type. This might be an issue when trying to distinguish between <em>structurally</em> equivalent types that are <em>nominally</em> different. As an example, consider a <code>UserID</code> and <code>PostID</code> that are both represented as strings:",$,v,ss=`<pre class="shiki shiki-themes github-light slack-dark twoslash lsp" style="background-color:#fff;--shiki-dark-bg:#222222;color:#24292e;--shiki-dark:#E6E6E6" tabindex="0" ts twoslash highlight="[object Object]"><code><span class="line"><span style="color:#D73A49;--shiki-dark:#569CD6">type</span><span style="color:#6F42C1;--shiki-dark:#4EC9B0"> </span><span style="color:#6F42C1;--shiki-dark:#4EC9B0"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span class="line"><span style="color:#D73A49;--shiki-dark:#569CD6">type</span><span style="color:#6F42C1;--shiki-dark:#4EC9B0"> UserID</span><span style="color:#D73A49;--shiki-dark:#D4D4D4"> =</span><span style="color:#005CC5;--shiki-dark:#4EC9B0"> string</span></span></code></span>UserID</span></span><span style="color:#D73A49;--shiki-dark:#D4D4D4"> =</span><span style="color:#005CC5;--shiki-dark:#4EC9B0"> string</span><span style="color:#24292E;--shiki-dark:#E6E6E6">;</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#569CD6">type</span><span style="color:#6F42C1;--shiki-dark:#4EC9B0"> </span><span style="color:#6F42C1;--shiki-dark:#4EC9B0"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span class="line"><span style="color:#D73A49;--shiki-dark:#569CD6">type</span><span style="color:#6F42C1;--shiki-dark:#4EC9B0"> PostID</span><span style="color:#D73A49;--shiki-dark:#D4D4D4"> =</span><span style="color:#005CC5;--shiki-dark:#4EC9B0"> string</span></span></code></span>PostID</span></span><span style="color:#D73A49;--shiki-dark:#D4D4D4"> =</span><span style="color:#005CC5;--shiki-dark:#4EC9B0"> string</span><span style="color:#24292E;--shiki-dark:#E6E6E6">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#569CD6">let</span><span style="color:#24292E;--shiki-dark:#9CDCFE"> </span><span style="color:#24292E;--shiki-dark:#9CDCFE"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span class="line"><span style="color:#D73A49;--shiki-dark:#569CD6">let</span><span style="color:#24292E;--shiki-dark:#9CDCFE"> user</span><span style="color:#D73A49;--shiki-dark:#D4D4D4">:</span><span style="color:#005CC5;--shiki-dark:#4EC9B0"> string</span></span></code></span>user</span></span><span style="color:#D73A49;--shiki-dark:#D4D4D4">:</span><span style="color:#6F42C1;--shiki-dark:#4EC9B0"> </span><span style="color:#6F42C1;--shiki-dark:#4EC9B0"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span class="line"><span style="color:#D73A49;--shiki-dark:#569CD6">type</span><span style="color:#6F42C1;--shiki-dark:#4EC9B0"> UserID</span><span style="color:#D73A49;--shiki-dark:#D4D4D4"> =</span><span style="color:#005CC5;--shiki-dark:#4EC9B0"> string</span></span></code></span>UserID</span></span><span style="color:#D73A49;--shiki-dark:#D4D4D4"> =</span><span style="color:#032F62;--shiki-dark:#CE9178"> "allan"</span><span style="color:#24292E;--shiki-dark:#E6E6E6">;</span></span>
<span class="line highlighted"><span style="color:#D73A49;--shiki-dark:#569CD6">let</span><span style="color:#24292E;--shiki-dark:#9CDCFE"> </span><span style="color:#24292E;--shiki-dark:#9CDCFE"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span class="line"><span style="color:#D73A49;--shiki-dark:#569CD6">let</span><span style="color:#24292E;--shiki-dark:#9CDCFE"> post</span><span style="color:#D73A49;--shiki-dark:#D4D4D4">:</span><span style="color:#005CC5;--shiki-dark:#4EC9B0"> string</span></span></code></span>post</span></span><span style="color:#D73A49;--shiki-dark:#D4D4D4">:</span><span style="color:#6F42C1;--shiki-dark:#4EC9B0"> </span><span style="color:#6F42C1;--shiki-dark:#4EC9B0"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span class="line"><span style="color:#D73A49;--shiki-dark:#569CD6">type</span><span style="color:#6F42C1;--shiki-dark:#4EC9B0"> PostID</span><span style="color:#D73A49;--shiki-dark:#D4D4D4"> =</span><span style="color:#005CC5;--shiki-dark:#4EC9B0"> string</span></span></code></span>PostID</span></span><span style="color:#D73A49;--shiki-dark:#D4D4D4"> =</span><span style="color:#24292E;--shiki-dark:#9CDCFE"> </span><span style="color:#24292E;--shiki-dark:#9CDCFE"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span class="line"><span style="color:#D73A49;--shiki-dark:#569CD6">let</span><span style="color:#24292E;--shiki-dark:#9CDCFE"> user</span><span style="color:#D73A49;--shiki-dark:#D4D4D4">:</span><span style="color:#005CC5;--shiki-dark:#4EC9B0"> string</span></span></code></span>user</span></span><span style="color:#24292E;--shiki-dark:#E6E6E6">;</span></span></code></pre>`,w,F,as=`<pre class="code-copy-target hidden">type UserID = string;
type PostID = string;

let user: UserID = "allan";
let post: PostID = user;</pre>`,B,m,q="These are two different <em>named</em> types but because they are <em>structurally</em> identical TypeScript will allow you to assign a <code>UserID</code> value to a <code>PostID</code> object. Yikes! Compatibility makes problems like this possible.",I,f,N='Fortunately, it can be solved in TypeScript. <a href="/notes/Type%20branding%20removes%20structural%20type%20compatibility/">Type branding removes structural type compatibility</a>, and can be used to prevent this type of problem.',H;return n=new os({props:{$$slots:{default:[rs]},$$scope:{ctx:h}}}),{c(){a=y("p"),a.innerHTML=r,o=d(),G(n.$$.fragment),t=d(),e=y("p"),e.textContent=c,T=d(),b=new L(!1),A=S(),_=new L(!1),g=d(),C=y("p"),C.innerHTML=j,x=d(),E=y("p"),E.innerHTML=U,$=d(),v=new L(!1),w=S(),F=new L(!1),B=d(),m=y("p"),m.innerHTML=q,I=d(),f=y("p"),f.innerHTML=N,this.h()},l(s){a=D(s,"P",{["data-svelte-h"]:!0}),u(a)!=="svelte-2kmkxw"&&(a.innerHTML=r),o=k(s),J(n.$$.fragment,s),t=k(s),e=D(s,"P",{["data-svelte-h"]:!0}),u(e)!=="svelte-44hwdv"&&(e.textContent=c),T=k(s),b=M(s,!1),A=S(),_=M(s,!1),g=k(s),C=D(s,"P",{["data-svelte-h"]:!0}),u(C)!=="svelte-1lw6j2q"&&(C.innerHTML=j),x=k(s),E=D(s,"P",{["data-svelte-h"]:!0}),u(E)!=="svelte-rhottr"&&(E.innerHTML=U),$=k(s),v=M(s,!1),w=S(),F=M(s,!1),B=k(s),m=D(s,"P",{["data-svelte-h"]:!0}),u(m)!=="svelte-5ewpk0"&&(m.innerHTML=q),I=k(s),f=D(s,"P",{["data-svelte-h"]:!0}),u(f)!=="svelte-1yxotue"&&(f.innerHTML=N),this.h()},h(){b.a=A,_.a=g,v.a=w,F.a=B},m(s,l){i(s,a,l),i(s,o,l),K(n,s,l),i(s,t,l),i(s,e,l),i(s,T,l),b.m(Q,s,l),i(s,A,l),_.m(W,s,l),i(s,g,l),i(s,C,l),i(s,x,l),i(s,E,l),i(s,$,l),v.m(ss,s,l),i(s,w,l),F.m(as,s,l),i(s,B,l),i(s,m,l),i(s,I,l),i(s,f,l),H=!0},p(s,l){const V={};l&2&&(V.$$scope={dirty:l,ctx:s}),n.$set(V)},i(s){H||(R(n.$$.fragment,s),H=!0)},o(s){X(n.$$.fragment,s),H=!1},d(s){s&&(p(a),p(o),p(t),p(e),p(T),p(A),b.d(),_.d(),p(g),p(C),p(x),p(E),p($),p(w),v.d(),F.d(),p(B),p(m),p(I),p(f)),z(n,s)}}}function ds(h){let a,r;const o=[h[0],Z];let n={$$slots:{default:[cs]},$$scope:{ctx:h}};for(let t=0;t<o.length;t+=1)n=P(n,o[t]);return a=new ps({props:n}),{c(){G(a.$$.fragment)},l(t){J(a.$$.fragment,t)},m(t,e){K(a,t,e),r=!0},p(t,[e]){const c=e&1?is(o,[e&1&&Y(t[0]),e&0&&Y(Z)]):{};e&2&&(c.$$scope={dirty:e,ctx:t}),a.$set(c)},i(t){r||(R(a.$$.fragment,t),r=!0)},o(t){X(a.$$.fragment,t),r=!1},d(t){z(a,t)}}}const Z={title:"Structural types increase data compatibility",description:"Structural types are only concerned with the shape of data, rather than the names of types. This makes data types more compatible.",slug:"structural-types-increase-compatibility",publish:!0,lastmod:"2024-02-04T00:00:00.000Z",date:"2024-02-04T00:00:00.000Z",aliases:null,tags:["status/seedling","topic/typescript"],timeToRead:2,internalLinks:["/notes/Type%20branding%20removes%20structural%20type%20compatibility/"],flashcards:[]};function ks(h,a,r){return h.$$set=o=>{r(0,a=P(P({},a),O(o)))},a=O(a),[a]}class Es extends ls{constructor(a){super(),ns(this,a,ks,ds,es,{})}}export{Es as default,Z as metadata};
