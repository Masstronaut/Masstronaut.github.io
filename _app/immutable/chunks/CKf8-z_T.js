const t="---\ntitle: Classy coding - JavaScript OOP through the ages\ndescription: Embark on a journey to learn about how OOP has been done throughout JavaScript's history, with our destination set on understanding how we should do it today and what all the modern syntax is doing for us under the hood.\nslug: notes/classy-javascript\npublish: true\nlastmod: 2024-08-14\ndate: 2024-08-14\naliases: null\ntags:\n- status/budding\n---\n\nThis blog post was originally presented at SeattleJS in August 2024.\n\n## Constructing a class in JavaScript\n\nObject-Oriented Programming (OOP) has been around for a long time and in many languages. JavaScript is no exception to that, which should come as no surprise to anyone using JS today. It hasn't always been a first-class paradigm in the language, though.\n\nLet's embark on a journey to learn about how OOP has been done throughout JavaScript's history, with our destination set on understanding how we should do it today and what all the modern syntax is doing for us under the hood.\n\n### The prototype chain\n\nImagine a classic OOP problem - you have a bunch of objects that share an \"is a\" relationship. This \"is a\" relationship is typically used to explain when multiple objects should share a \"class\" type. I'll use rectangles to keep it easy. So we have a bunch of objects, each of which \"is a\" rectangle - how do we represent that so and give each rectangle instance the interface a rectangle class should have?\n\nTo start, let's make a rectangle instance. Write or paste this code into your browser console to make one:\n\n````ts\nlet rect1 = {width: 4, height: 5};\nrect1\n````\n\nThe second line should cause the console to display a reference to the `rect1` object. You may have noticed that both properties fit in a single line, but the dev tools still give you an option to expand the object. Isn't that weird?\n\n<picture>\n<source media=\"(prefers-color-scheme: dark)\" srcset=\"https://img.allandeutsch.com/allandeutschcom-note-images/f72f079f9b507f25ba5f58187d5768d0.png\"/>\n<source media=\"(prefers-color-scheme: light )\" srcset=\"https://img.allandeutsch.com/allandeutschcom-note-images/543e3014b14c74e0bdc5fb83b0c8a034.png\"/>\n<img alt=\"The chrome dev tools showing the rectangle's width and height properties and values, as well as an arrow icon to expand the view.\"/>\n</picture>\n\nIf my object only those two properties and they both fit on screen, why would I need to expand it?\n\nAs you'll quickly find, there's my `height` and `width` properties, as well as some weird `[[Prototype]]` object. Continuing to expand the `[[Prototype]]` object reveals a few more things. Some of them, like `toString()` and `hasOwnProperty()` probably look familiar. Others, such as `isPrototypeOf()` may not be.\n\nYou see, JavaScript has an unusual approach to inheritance called a *prototype chain*. It's a linked list of object instances. Each instance makes up one part of the object. I think it's easier to understand interactive exploration, so crack open your browser dev console or favorite JS REPL and let's explore!\n\nThe special `[[Prototype]]` property on this object by default is called *the* object prototype. Whenever you create an object in JS, the object prototype is added to your object's prototype chain automatically. You can also access it without dev tools by using an arcane incantation: `rect1.__proto__`. Entering that in the dev tools console will show the same thing as expanding the `[[Prototype]]` object, and that's because it *is* the same object.\n\nBut how does this relate to our rectangle? Well it turns out that you can specify a custom prototype object. Think of prototype objects as a \"class\" or \"class type\" from other languages. First, let's define the functionality of our rectangle class:\n\n````ts\nconst baseRectangle = {\n	isSquare: function() { return this.width === this.height },\n	area: function() { return this.width * this.height }\n}\n````\n\nNow I can add this to the prototype chain for `rect1`:\n\n````ts\nrect1.__proto__ = baseRectangle;\n````\n\nWhen accessing a property on an object, if the object doesn't have the property then the JS runtime will look for it further down the prototype chain (on the `__proto__` property) of the object. For example, accessing `rect1.isSquare()`:\n\n1. The JS runtime checks the `rect1` object, which only has `width`, `height`, and `__proto__` properties.\n1. The runtime checks the object at `__proto__` for `isSquare` and finds it. Done!\n\nAs an aside, it's also worth understanding the **chain** part of the prototype chain. `rect1` isn't the only object so far whose prototype was set to the object prototype when created: `baseRectangle`'s was too! Even though I've changed the prototype for `rect1`, I can still use methods from the prototype object on it. For example, if I want to check if `rect1.isPrototypeOf(baseRectangle)`, that will work! The JS runtime resolves the call like this:\n\n1. It checks `rect1` for an `isPrototypeOf` property and fails to find it.\n1. It then checks for `rect1.__proto__` which exists, so it checks `rect1.__proto__` for `isPrototypeOf`.\n1. `rect1.__proto__` has no `isPrototypeOf` method, so it checks if `rect1.__proto__.__proto__` exists. Since it does, it continues searching the *prototype chain*\n1. `rect1.__proto__.__proto__` *does* have an `isPrototypeOf` method, so that gets resolved as the `rect1.isPrototypeOf()` method and is invoked.\n1. Extra credit: The function call checks if `rect1 === baseRectangle.__proto__` and returns false. `baseRectangle` is the prototype of `rect1`, not the other way around!\n\nSo running `rect1.isSquare()` has the expected behavior:\n\n* The `isSquare()` function is found\n* `rect1` is bound as `this`, so the function has access to its `width` and `height` values\n* The console displays `20`, the result of multiplying `4*5`.\n\nWe're off to a great start, and it's easy enough to make more rectangles and extend them with the `baseRectangle` functionality:\n\n````js\nconst rect2 = { width: 3, height: 3, __proto__: baseRectangle };\n````\n\nExplicitly setting `__proto__` feels pretty gross though. Also, we run into some weird behavior if we mistakenly try to interact with `baseRectangle` directly. As an example, it has neither a width nor height. Despite that, calling `baseRectangle.isSquare()` returns `true`. What the heck?\n\nSince `baseRectangle` has neither `width` nor `height`, when `isSquare()` is invoked directly on it `this.width` and `this.height` are both `undefined`. In JavaScript, `undefined === undefined`. Yikes!\n\nSo this approach leaves us with 2 gaping flaws - explicitly setting `__proto__` is gross and using the prototype object directly has undesirable behavior. Fortunately, there's an easy way to make this better.\n\n### Encapsulate prototype chain modifications during object construction\n\nThe most common pattern for ensuring new object instances are created consistently is to encapsulate it into a function. This type of function is called a \"constructor\" function. We can make a \"constructor\" function that creates an object, sets `__proto__` on it, and then returns the object. Consumers of this constructor function can pass in the parameters, and the function can handle the icky JS internals for them. Something like this should do the trick:\n\n````js\nfunction makeRectangle(width, height) {\n  return { width, height, __proto__: baseRectangle };\n//                        ^^^^^^^^^^^^^^^^^^^^^^^^\n}\n\nconst aSquare = makeRectangle(4,4);\naSquare.isSquare(); // true\n````\n\nThat's easy enough! Unfortunately the `baseRectangle` object still needs to be defined somewhere and it could be mistakenly used. Also, this whole `__proto__` syntax is pretty gross and feels like a leaky abstraction. This code is hard to understand if you haven't explicitly learned about the prototype chain and the magic `__proto__` member. I'd been using JS for several years before I learned about it!\n\nHow can we make this better? Fortunately, OG JavaScript has an answer!\n\n### The `new` operator\n\nThis pattern - using a constructor to setup an object's prototype chain - is the original design intent. The above example gets some of the details wrong, though:\n\n* Implementing a prototype object that is floating around\n* Implementing a separate constructor function\n* Explicitly setting the `__proto__` property\n\nJavaScript has an alternate syntax for setting up a prototype chain, and it hinges on another unique feature of the language. As it turns out, functions in JavaScript are objects. Don't believe me? Try this out:\n\n````js\nconsole.log( makeRectangle instanceof Object );\n// true\n````\n\nPractically, this means functions can have properties just like any other object. Functions also have a `__proto__` property by default - they get the *function* prototype object. If you've ever noticed that functions have methods like `apply` and `bind` on them: this is why.\n\nThe *function* prototype object in turn has its `__proto__` set to the *object* prototype. So the prototype chain for a function (which is an object) has both the **function prototype** and the **object prototype**. Looking at the properties of a function, we can values from both. These include `apply` from the **function** prototype and `toString` from the **object** prototype.\n\n````ts twoslash\n// @errors: 7023 2339 7006\nconst baseRectangle = {\n	isSquare: function(): boolean { return this.width === this.height },\n	area: function(): number { return this.width * this.height }\n};\n\nfunction makeRectangle(width, height) {\n  return { width, height, __proto__: baseRectangle };\n}\n//---cut---\nmakeRectangle.apply\n//            ^|\n\n\n\n\n\n\n\n\n\n````\n\n\"Okay Allan, how is the fact that functions are objects relevant to constructor functions?\" Great question! The short answer is that if we want to implement a class, we don't need to define the class interface (prototype object) and the class constructor function as *separate* entities.\n\nInstead, the prototype object should be a property of the constructor function object. for example:\n\n````js\nfunction constructRectangle(width, height) {\n	return { width, height, __proto__: constructRectangle.prototype }\n}\nconstructRectangle.prototype = {\n	isSquare: function() { return this.width === this.height },\n	area: function() { return this.width * this.height }\n};\n\nconst rect3 = constructRectangle(1,2);\nrect3.isSquare(); // false\n````\n\nThis solves the problem of the floating rectangle prototype; it's now firmly anchored to the constructor function where it belongs. It still has some shortcomings though:\n\n1. Explicitly setting the `__proto__` on the rectangle instance it returns\n1. In fact, everything about `__proto__: constructRectangle.prototype` is icky.\n1. I still have to explicitly create and return the new object I'm constructing.\n\nJavaScript has a special solution for this: the `new` operator. It gets placed before a function call, ie `new rectangle(...)` and it augments the function call with some special behavior:\n\n1. it creates a *new* (heh) object\n1. It sets the new object's `__proto__` property to the function's `prototype` property.\n1. it bind `this` to the new object in the function call, equivalent to doing `rectangle.apply(newObj, ...)`\n1. The expression evaluates to the new object after the function call returns\n\nThat's a lot to take in! It might be easier to understand with an example of the `new` (heh) version of my rectangle constructor function and its usage:\n\n````js\nfunction Rectangle(width, height) {\n	// when called with `new`:\n	// 1. `this` is set to a new object.\n	// Just set the properties directly!\n	this.width = width;\n	this.height = height;\n\n	// 2. the __proto__ is set automatically to `Rectangle.prototype`\n	// No need to set it explicitly here!\n	\n\n	// 3. The `new` expression resolves as `this` new object\n	// no need to explicitly return it.\n}\nRectangle.prototype = {\n	isSquare: function() { return this.width === this.height },\n	area:     function() { return this.width  *  this.height }\n};\n\n// usage:\nconst rect4 = Rectangle(2,4)\nrect4; // ...undefined?\n````\n\nWhy is `rect4` undefined? Because `Rectangle` was called without using `new`. Yikes! Fortunately, it's an easy fix.\n\n > \n > I presented this talk at the SeattleJS August 2024 meetup, where a couple people had a great question: what is the `this` object that `Rectangle()` sets a `width` and `height` on when it is called *without* `new`?\n > \n > The answer, as usual, is \"it depends.\" Since `this` isn't bound for the function call, it will use the global this in the context of the call. In a browser `this` is the window object. In node at the top level, `this` is the `globalThis` object. In an ES module, `this` is undefined.\n\nThe easy fix is to prefix the `Rectangle()` call with `new`:\n\n````js\nconst rect5 = new Rectangle(2,4);\nrect5.isSquare(); // false\n````\n\nWhew, that works! Overall I think this code looks a lot cleaner than before. The `Rectangle` class interface is neatly encapsulated as `Rectangle.prototype`. Once you're familiar with the `new` operator this code is easy to read.\n\n > \n > Once you're familiar with the `new` operator this code is easy to read.\n\nHold up! That's not great. In fact, it might be terrible. If you call it without `new`, this version of the `Rectangle` constructor just touches itself and doesn't produce anything.\n\nWorse than that, anyone unfortunate enough to call a constructor *without* `new` won't even be given an error. Just the mysterious nothingness that is `undefined`, quietly slipped into your variable under the table in hopes that nobody notices. Spectacular! Why would anyone use this stupid language?\n\nBrowsers! Right, of course. So how do we fix this?\n\n### Ensuring constructors are called correctly\n\nThere are a few approaches. One is a simple convention - constructor functions start with a capital letter (like `Rectangle`) and everything else starts with a lower case. The convention of capitalizing class names is common in other OOP languages too. If you didn't know, now ya know!\n\nHelpful, but we've still got a weird IYKYK situation going on here. If you don't know you're supposed to use `new` with capitalized functions, you're going to get an `undefined` and that's not helpful. It would be great if *inside* the constructor function we could check if `new` was used. That would work to verify *this* call was made correctly.\n\nSpeaking of *this*, `this` is set if `new` was used. I'll just check that inside my constructor function!\n\n````js\nfunction Rectangle(width, height) {\n	if(this.__proto__ !== Rectangle.prototype) {\n		// call this function correctly\n		return new Rectangle(width, height);\n	}\n	this.width = width;\n	this.height = height;\n}\nRectangle.prototype = {\n	isSquare: function() { return this.width === this.height },\n	area:     function() { return this.width  *  this.height }\n}\n\n// usage\nconst newRect = new Rectangle(1, 2);\nconst alsoNewRect = Rectangle(3.1415, 3.1415);\n````\n\nNow the only way to screw up this function call is by not passing it a width and height. That feels like a reasonable expectation to have of a `Rectangle` consumer.\n\nIt comes at a cost, though: that nasty `__proto__` JS implementation detail crept back in. Gross! If only there were a better way to check what `this` is...\n\nAs I'm sure you can guess at this point, there is! It's been around since way back in the days of ECMAScript 1, the first standardized JS release from 1997. We've got a whole 'nother keyword *just for this*! You've probably used it whenever you wanted to know if an object was an `instanceof` a class. Now you know what it's doing under the hood!\n\n````js\nfunction Rectangle(width, height) {\n	if( !(this instanceof Rectangle) ) {\n		return new Rectangle(width, height);\n	}\n	// ...\n}\n````\n\nThere are a couple things I love about where we ended up here:\n\n1. The *intention* of this code is extremely clear. It's easy to understand even if you don't know the behavior of the `new` operator or the JS prototype chain implementation details.\n1. If you are making a constructor, this pattern at the top of the function makes it recognizable as one. IYKYK\n\nThis style of if statement, which checks that a necessary condition is met and if not the function returns early, is called a *guard clause*. They're a great technique for keeping code readable.\n\n#### Factory functions\n\nAnother approach is to avoid the prototype chain, constructor functions, and `new` entirely. Instead, the *factory pattern* can be used. If you're not familiar, the factory pattern uses a \"factory function\" to produce objects of some standardized format, very similar to a constructor function. Here's a factory example:\n\n````js\nfunction makeRectangle(width, height) {\n	return {\n		width,\n		height,\n		isSquare: function() { return width === height; },\n		area: function() { return width * height; }\n	}\n}\n````\n\nThis looks a lot like an earlier version of the constructor function. It has a few downsides compared to using a class constructor though:\n\n1. The factory creates a new copy of the `isSquare` and `area` functions for each object instance it creates. That's because the functions need to create a \"closure\" which captures a reference to the `width` and `height` values for the instance - every object has its own copy and each copy uses memory. **Objects created using a constructor share one prototype object instance, reducing memory usage.**\n1. The `instanceof` operator can be used anywhere. I can check if any object was made using a specific constructor with `obj instanceof Rectangle`. As we learned, it works by checking the `__proto__` of an object. Factory functions don't set `__proto__`, so you can't check if an object was produced by a specific factory function with `instanceof`.\n\nGenerally speaking, if a constructor function can do what you need, it's a better choice than a factory function. There are cases where a factory function is better, but that is a topic for another article...\n\nSo now we have a good understanding of how to create a bunch of objects of the same \"class\" in JS. What's next?\n\n## Getting classy\n\nSince the first JavaScript standard, ECMAScript 1, this was the best way to write `class`y code in JavaScript.\n\n🕐 🕝 🕤 🕛 *20 years later*\n\nThen along came ECMAScript 6 (ES2015), and with it the introduction of official support for `class`es and `constructor`s in JavaScript. Here's what a rewrite using the new syntax looks like:\n\n````js\nclass Rectangle {\n	// It's explicitly called a constructor now\n	// This makes it much more discoverable for a new dev\n	constructor( width, height ) {\n		this.width = width;\n		this.height = height;\n	}\n\n	// No longer need to use `__proto__` or `prototype` properties\n	isSquare() {\n		return this.width === this.height;\n	}\n\n	area() {\n		return this.width * this.height;\n	}\n}\n\n// usage\nconst classyRectangle = new Rectangle(1, 7);\nclassyRectangle.isSquare(); // false\nclassyRectangle instanceof Rectangle; // true\nconst classyRectangle2 = Rectangle(1, 6); // ERROR!\n````\n\nThis has lots of amazing improvements. First and foremost, the intent is much more clearly communicated to the reader. This is *explicitly* a `class`, not just a function that walks and talks like one. Any programmer new to JS can figure out they should search for `class javascript` for more information to help them understand what's going on.\n\nThis continues with the explicit requirement of a function named `constructor`. Very searchable, very explicit. When `new Rectangle()` is written, the `Rectangle` class `constructor` method gets called. No more sketchy functions that touch themselves, now our code is so `class`y it can't be missed!\n\nThe special behavior of `new` better hidden now too. It's not as important to understand it's behavior when used with a `class`. Most importantly, trying to construct a `Rectangle` without `new` provides an extremely clear and easy to understand error message:\n\n````\nUncaught TypeError: Class constructor Rectangle cannot be invoked without 'new'\n````\n\nAmazing! As a result, we no longer need to start every constructor with a guard that checks `this instanceof Rectangle`. Less code to write, less code to read, and easier to understand what's going on. Fantastic!\n\nFinally, we no longer need to explicitly set up a `prototype` object. Put the members on the `class` object, and anything that is set outside the `constructor()` function is automatically put onto the prototype by the JS runtime. This change means you can now use classes effectively without understanding all the complexity of the prototype chain.\n\n## Protecting your privates\n\nFast-forward a while and we are constructing classy `Rectangle`s all over the place. One of our uses involves packing rectangles together. This was working great until the packed `Rectangle`s started shape-shifting. Somewhere, somehow, the packed rectangles are being *mutated*. It's really easy to do:\n\n````js\nconst shapeshiftingRectangle = new Rectangle(1,2);\n// pack away the rectangle...\n\n// and now it can still be changed! yikes\nshapeshiftingRectangle.width = 640;\nshapeshiftingRectangle.height = 480;\n````\n\nAaaah! The `Rectangle`s private dimensions are exposed, and can therefore be changed. This exhibitionist behavior is unbefitting of a `class`y `Rectangle`.\n\nWe need a version of `Rectangle` that isn't such an exhibitionist. Its `width` and `height` are private, and should be treated as such so nobody else can touch them.\n\nThrough JavaScript's long history, the answer has typically been a closure. Closures work because of how memory is managed in JS. As long as a a variable is referenced somewhere, it will be kept in memory. If we create a function that references a local variable, it forms a closure and keeps the variable in memory. So consider this version of the `Rectangle` class:\n\n````js\nclass ImmutableRectangle {\n	constructor(width, height) {\n		const _width = width;\n		const _height = height;\n\n		// Now the values are only exposed as functions\n		// Can't change the values now!\n		this.width    = function() { return _width;  };\n		this.height   = function() { return _height; };\n	}	\n	isSquare() { \n		return this.width() === this.height(); \n	}\n	area() { \n		return this.width()  *  this.height(); \n	}\n}\n// usage\nconst immutableRect = new ImmutableRectangle(4, 5);\nimmutableRect.width; // [Function (anonymous)]\nimmutableRect.width(); // 4\nimmutableRect._width; // undefined\nimmutableRect.isSquare(); // false\n````\n\nSince the `_width` and `_height` are `const` values and only accessible from inside the `Rectangle`'s `constructor` function, they are \"private\" and nobody else can see or touch them. I solved the \"see them\" problem by adding a couple getter functions, `width()` and `height()`, which return their respective values. This lets me protect my `Rectangle`'s privates, but it comes at a cost.\n\nSimilar to a factory function, each constructor call is creating a new copy of the `width()` and `height()` functions to form a closure on its `_width` and `_height`, using more memory. That's not a terrible way to make sure `Rectangle`'s members are private. As it turns out, even with the introduction of classes in ES6 that is the best way to do it. The end.\n\n🕐 🕝  *7 years later*\n\nAfter another long wait, ECMAScript 2022 (ES13) came along and introduced proper language-level support for private properties. These classy new classes can finally hide their privates. Unlike TikTok and Instagram, hashtags in JS are for the *opposite* of discoverability. `#private` `#youcantseeme` eh? Check this out:\n\n````js\nclass Rectangle {\n	#width;\n	#height;\n	constructor( width, height ) {\n		this.#width = width;\n		this.#height = height;\n	}\n	isSquare() {\n		return this.#width === this.#height;\n	}\n	area() {\n		return this.#width * this.#height;\n	}\n}\nlet privateRect = new Rectangle(1,2);\nprivateRect.area(); // 2\nprivateRect.#width; // Error!\n````\n\nNow the runtime will not let anyone else touch our `Rectangle`'s privates!\n\nAs of 2022 we've finally got language-level support for basic Object-Oriented Programming in JavaScript!\n\nIt's been quite a journey to get here. I hope it was a fun one!\n";export{t as default};
