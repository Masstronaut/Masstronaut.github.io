import{s as es,p as S,q as z,e as y,a as d,H as $,u as H,c as u,m as A,g as k,v as j,i,f as p,n as ts}from"./scheduler.ewBkyc9q.js";import{S as ls,i as ns,c as W,a as Y,m as Z,t as N,b as R,d as J}from"./index.DpmaPz1F.js";import{g as is,a as O}from"./spread.CgU5AtxT.js";import{M as ps}from"./MDSveXNoteLayout.DP6RGFyM.js";import{T as os}from"./Table.CQjGI0Gm.js";function rs(h){let a,r="<tr><th></th> <th>Nominal</th> <th>Structural</th></tr>",o,n,t="<tr><td>Languages</td> <td>C, C++, Java, C#</td> <td>TypeScript, Go</td></tr> <tr><td>Type compatibility requirements</td> <td>Structure and name</td> <td>Structure</td></tr> <tr><td>Specificity</td> <td>Strict</td> <td>Flexible</td></tr>";return{c(){a=y("thead"),a.innerHTML=r,o=d(),n=y("tbody"),n.innerHTML=t},l(e){a=u(e,"THEAD",{"data-svelte-h":!0}),A(a)!=="svelte-rsxkvl"&&(a.innerHTML=r),o=k(e),n=u(e,"TBODY",{"data-svelte-h":!0}),A(n)!=="svelte-1m6m8v6"&&(n.innerHTML=t)},m(e,c){i(e,a,c),i(e,o,c),i(e,n,c)},p:ts,d(e){e&&(p(a),p(o),p(n))}}}function cs(h){let a,r="Typescript uses an approach to types called “structural typing”. Structural types are compatible if they share the same structure: the same named members and those members have the same types. This differs from languages such as C &amp; C++ which use an approach called “nominal typing.” Nominal types are only equivalent if they share the same structure <strong>and name</strong>. Here’s a quick reference:",o,n,t,e,c="I find it easiest to understand how structural types work with code examples:",x,g,V=`<pre class="shiki shiki-themes vitesse-light vitesse-dark" style="background-color:#ffffff;--shiki-dark-bg:#121212;color:#393a34;--shiki-dark:#dbd7caee" tabindex="0" data-tsplay="https://typescriptlang.org/play/#code/C4TwDgpgBAglC8UDeUCGAuKA7ArgWwCMIAnKAXwG4AoUSKAIQWTU10JIBooDMBnYYgEssAc3LUqAeklQABqgCMsqIN5QIADzAAbQQGNBwbSCi0IAEzRrUWOTGUB7AgCsIe4FW0RgaBZjiIKBhQCgBMAMziUjLyocqq2A4+mjr6hsam4BZWdrIAdAWe3mihTEGY4aEKUdIMOD6GavzEOO44xNB4qMB6ABYQvBzRULwOKj56NtzQqLy8giJY2cBjqJl0svZQTq7uVIpMqKEUULUAaqi65lTDsgTxaim6BkYmZpazaHL0ji5uHl4fDwGGVggpwgBWLjAgBEqAIehhlFu9ygk1sRCs80Wy1Wtk2v12PmGREmOF40EMKmsIxwkGIFJ8DgAZqZ+iMBK1gO1oCzYPtSogCCdzpdBOYgA"><code><span class="line"><span style="color:#AB5959;--shiki-dark:#CB7676">type</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> A</span><span style="color:#999999;--shiki-dark:#666666"> =</span><span style="color:#999999;--shiki-dark:#666666"> &#123;</span><span style="color:#B07D48;--shiki-dark:#BD976A"> a</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">number</span><span style="color:#999999;--shiki-dark:#666666"> &#125;;</span></span>
<span class="line"><span style="color:#AB5959;--shiki-dark:#CB7676">type</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> B</span><span style="color:#999999;--shiki-dark:#666666"> =</span><span style="color:#999999;--shiki-dark:#666666"> &#123;</span><span style="color:#B07D48;--shiki-dark:#BD976A"> a</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">number</span><span style="color:#999999;--shiki-dark:#666666">,</span><span style="color:#B07D48;--shiki-dark:#BD976A"> b</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">string</span><span style="color:#999999;--shiki-dark:#666666"> &#125;;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A0ADA0;--shiki-dark:#758575DD">// &#96;a1&#96; is explicitly typed as an &#96;A&#96; object</span></span>
<span class="line"><span style="color:#AB5959;--shiki-dark:#CB7676">let </span><span style="color:#B07D48;--shiki-dark:#BD976A">a1</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">A</span><span style="color:#999999;--shiki-dark:#666666"> =</span><span style="color:#999999;--shiki-dark:#666666"> &#123; </span><span style="color:#998418;--shiki-dark:#B8A965">a</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2F798A;--shiki-dark:#4C9A91">123</span><span style="color:#999999;--shiki-dark:#666666"> &#125;;</span></span>
<span class="line"><span style="color:#A0ADA0;--shiki-dark:#758575DD">// &#96;a2&#96; is not explicitly typed as &#96;A&#96;...</span></span>
<span class="line"><span style="color:#AB5959;--shiki-dark:#CB7676">let </span><span style="color:#B07D48;--shiki-dark:#BD976A">a2</span><span style="color:#999999;--shiki-dark:#666666"> =</span><span style="color:#999999;--shiki-dark:#666666"> &#123; </span><span style="color:#998418;--shiki-dark:#B8A965">a</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2F798A;--shiki-dark:#4C9A91">321</span><span style="color:#999999;--shiki-dark:#666666"> &#125;;</span></span>
<span class="line"><span style="color:#A0ADA0;--shiki-dark:#758575DD">// But its structure matches,</span></span>
<span class="line"><span style="color:#A0ADA0;--shiki-dark:#758575DD">// so it can be assigned to a type &#96;A&#96; object</span></span>
<span class="line"><span style="color:#B07D48;--shiki-dark:#BD976A">a1</span><span style="color:#999999;--shiki-dark:#666666"> =</span><span style="color:#B07D48;--shiki-dark:#BD976A"> a2</span><span style="color:#999999;--shiki-dark:#666666">;</span><span style="color:#A0ADA0;--shiki-dark:#758575DD"> // Valid</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A0ADA0;--shiki-dark:#758575DD">// &#96;b&#96; is explicitly typed as a &#96;B&#96; object</span></span>
<span class="line"><span style="color:#AB5959;--shiki-dark:#CB7676">let </span><span style="color:#B07D48;--shiki-dark:#BD976A">b</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">B</span><span style="color:#999999;--shiki-dark:#666666"> =</span><span style="color:#999999;--shiki-dark:#666666"> &#123;</span><span style="color:#998418;--shiki-dark:#B8A965">a</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2F798A;--shiki-dark:#4C9A91">135</span><span style="color:#999999;--shiki-dark:#666666">, </span><span style="color:#998418;--shiki-dark:#B8A965">b</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#B5695977;--shiki-dark:#C98A7D77">"</span><span style="color:#B56959;--shiki-dark:#C98A7D">abc</span><span style="color:#B5695977;--shiki-dark:#C98A7D77">"</span><span style="color:#999999;--shiki-dark:#666666">&#125;;</span></span>
<span class="line"><span style="color:#A0ADA0;--shiki-dark:#758575DD">// &#96;b&#96; can be assigned to an &#96;A&#96; object </span></span>
<span class="line"><span style="color:#A0ADA0;--shiki-dark:#758575DD">// because it is a superset of the structure of A</span></span>
<span class="line"><span style="color:#B07D48;--shiki-dark:#BD976A">a2</span><span style="color:#999999;--shiki-dark:#666666"> =</span><span style="color:#B07D48;--shiki-dark:#BD976A"> b</span><span style="color:#999999;--shiki-dark:#666666">;</span><span style="color:#A0ADA0;--shiki-dark:#758575DD"> // Valid</span></span></code></pre>`,b,w,X=`<pre class="code-copy-target hidden">type A = &#123; a: number &#125;;
type B = &#123; a: number, b: string &#125;;

// &#96;a1&#96; is explicitly typed as an &#96;A&#96; object
let a1: A = &#123; a: 123 &#125;;
// &#96;a2&#96; is not explicitly typed as &#96;A&#96;...
let a2 = &#123; a: 321 &#125;;
// But its structure matches,
// so it can be assigned to a type &#96;A&#96; object
a1 = a2; // Valid

// &#96;b&#96; is explicitly typed as a &#96;B&#96; object
let b: B = &#123;a: 135, b: "abc"&#125;;
// &#96;b&#96; can be assigned to an &#96;A&#96; object 
// because it is a superset of the structure of A
a2 = b; // Valid</pre>`,_,m,U="This approach is really convenient on the web where it’s common for data to come from external APIs; they may change the data provided. Structural typing makes it easy to handle extra data. In the <code>a2 = b</code> example above, the extra data on <code>b</code> is “sliced” off, narrowing it to an <code>A</code> object. The extra field on <code>B</code> doesn’t cause any issues! This makes it easy to opt-in to using additional data on a type when I’m ready, and to continue working until then.",F,D,q="TypeScript type compatibility can <em>reduce clarity</em> that a developer could otherwise provide using a named type. This might be an issue when trying to distinguish between <em>structurally</em> equivalent types that are <em>nominally</em> different. As an example, consider a <code>UserID</code> and <code>PostID</code> that are both represented as strings:",I,v,ss=`<pre class="shiki shiki-themes vitesse-light vitesse-dark twoslash lsp" style="background-color:#ffffff;--shiki-dark-bg:#121212;color:#393a34;--shiki-dark:#dbd7caee" tabindex="0" ts twoslash highlight="[object Object]" data-tsplay="https://typescriptlang.org/play/#code/C4TwDgpgBAqgzhATgSQCJQLxTsRBLAOwHMBuAKFEigAUB7HNTbXQ0ssgGwmCgFcFEALlgDGWAEQBDDh0kFx5LjzD1gwug3RZ+SEkA"><code><span class="line"><span style="color:#AB5959;--shiki-dark:#CB7676">type</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> </span><span style="color:#2E8F82;--shiki-dark:#5DA994"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:#AB5959;--shiki-dark:#CB7676">type</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> UserID</span><span style="color:#999999;--shiki-dark:#666666"> =</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> string</span></code></span>UserID</span></span><span style="color:#999999;--shiki-dark:#666666"> =</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> string</span><span style="color:#999999;--shiki-dark:#666666">;</span></span>
<span class="line"><span style="color:#AB5959;--shiki-dark:#CB7676">type</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> </span><span style="color:#2E8F82;--shiki-dark:#5DA994"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:#AB5959;--shiki-dark:#CB7676">type</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> PostID</span><span style="color:#999999;--shiki-dark:#666666"> =</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> string</span></code></span>PostID</span></span><span style="color:#999999;--shiki-dark:#666666"> =</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> string</span><span style="color:#999999;--shiki-dark:#666666">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#AB5959;--shiki-dark:#CB7676">let </span><span style="color:#B07D48;--shiki-dark:#BD976A"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:#AB5959;--shiki-dark:#CB7676">let </span><span style="color:#B07D48;--shiki-dark:#BD976A">user</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">string</span></code></span>user</span></span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:#AB5959;--shiki-dark:#CB7676">type</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> UserID</span><span style="color:#999999;--shiki-dark:#666666"> =</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> string</span></code></span>UserID</span></span><span style="color:#999999;--shiki-dark:#666666"> =</span><span style="color:#B5695977;--shiki-dark:#C98A7D77"> "</span><span style="color:#B56959;--shiki-dark:#C98A7D">allan</span><span style="color:#B5695977;--shiki-dark:#C98A7D77">"</span><span style="color:#999999;--shiki-dark:#666666">;</span></span>
<span class="line highlighted"><span style="color:#AB5959;--shiki-dark:#CB7676">let </span><span style="color:#B07D48;--shiki-dark:#BD976A"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:#AB5959;--shiki-dark:#CB7676">let </span><span style="color:#B07D48;--shiki-dark:#BD976A">post</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">string</span></code></span>post</span></span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:#AB5959;--shiki-dark:#CB7676">type</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> PostID</span><span style="color:#999999;--shiki-dark:#666666"> =</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> string</span></code></span>PostID</span></span><span style="color:#999999;--shiki-dark:#666666"> =</span><span style="color:#B07D48;--shiki-dark:#BD976A"> </span><span style="color:#B07D48;--shiki-dark:#BD976A"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:#AB5959;--shiki-dark:#CB7676">let </span><span style="color:#B07D48;--shiki-dark:#BD976A">user</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">string</span></code></span>user</span></span><span style="color:#999999;--shiki-dark:#666666">;</span></span></code></pre>`,C,T,as=`<pre class="code-copy-target hidden">type UserID = string;
type PostID = string;

let user: UserID = "allan";
let post: PostID = user;</pre>`,E,B,P="These are two different <em>named</em> types but because they are <em>structurally</em> identical TypeScript will allow you to assign a <code>UserID</code> value to a <code>PostID</code> object. Yikes! Compatibility makes problems like this possible.",L,f,G='Fortunately, it can be solved in TypeScript. <a href="/notes/structural-branded-types-nominal">Type branding removes structural type compatibility</a>, and can be used to prevent this type of problem.',M;return n=new os({props:{$$slots:{default:[rs]},$$scope:{ctx:h}}}),{c(){a=y("p"),a.innerHTML=r,o=d(),W(n.$$.fragment),t=d(),e=y("p"),e.textContent=c,x=d(),g=new $(!1),b=H(),w=new $(!1),_=d(),m=y("p"),m.innerHTML=U,F=d(),D=y("p"),D.innerHTML=q,I=d(),v=new $(!1),C=H(),T=new $(!1),E=d(),B=y("p"),B.innerHTML=P,L=d(),f=y("p"),f.innerHTML=G,this.h()},l(s){a=u(s,"P",{"data-svelte-h":!0}),A(a)!=="svelte-2kmkxw"&&(a.innerHTML=r),o=k(s),Y(n.$$.fragment,s),t=k(s),e=u(s,"P",{"data-svelte-h":!0}),A(e)!=="svelte-44hwdv"&&(e.textContent=c),x=k(s),g=j(s,!1),b=H(),w=j(s,!1),_=k(s),m=u(s,"P",{"data-svelte-h":!0}),A(m)!=="svelte-1lw6j2q"&&(m.innerHTML=U),F=k(s),D=u(s,"P",{"data-svelte-h":!0}),A(D)!=="svelte-rhottr"&&(D.innerHTML=q),I=k(s),v=j(s,!1),C=H(),T=j(s,!1),E=k(s),B=u(s,"P",{"data-svelte-h":!0}),A(B)!=="svelte-5ewpk0"&&(B.innerHTML=P),L=k(s),f=u(s,"P",{"data-svelte-h":!0}),A(f)!=="svelte-1npp2l8"&&(f.innerHTML=G),this.h()},h(){g.a=b,w.a=_,v.a=C,T.a=E},m(s,l){i(s,a,l),i(s,o,l),Z(n,s,l),i(s,t,l),i(s,e,l),i(s,x,l),g.m(V,s,l),i(s,b,l),w.m(X,s,l),i(s,_,l),i(s,m,l),i(s,F,l),i(s,D,l),i(s,I,l),v.m(ss,s,l),i(s,C,l),T.m(as,s,l),i(s,E,l),i(s,B,l),i(s,L,l),i(s,f,l),M=!0},p(s,l){const Q={};l&2&&(Q.$$scope={dirty:l,ctx:s}),n.$set(Q)},i(s){M||(N(n.$$.fragment,s),M=!0)},o(s){R(n.$$.fragment,s),M=!1},d(s){s&&(p(a),p(o),p(t),p(e),p(x),p(b),g.d(),w.d(),p(_),p(m),p(F),p(D),p(I),p(C),v.d(),T.d(),p(E),p(B),p(L),p(f)),J(n,s)}}}function ds(h){let a,r;const o=[h[0],K];let n={$$slots:{default:[cs]},$$scope:{ctx:h}};for(let t=0;t<o.length;t+=1)n=S(n,o[t]);return a=new ps({props:n}),{c(){W(a.$$.fragment)},l(t){Y(a.$$.fragment,t)},m(t,e){Z(a,t,e),r=!0},p(t,[e]){const c=e&1?is(o,[e&1&&O(t[0]),e&0&&O(K)]):{};e&2&&(c.$$scope={dirty:e,ctx:t}),a.$set(c)},i(t){r||(N(a.$$.fragment,t),r=!0)},o(t){R(a.$$.fragment,t),r=!1},d(t){J(a,t)}}}const K={title:"Structural types increase data compatibility",description:"Structural types are only concerned with the shape of data, rather than the names of types. This makes data types more compatible.",slug:"notes/structural-types-increase-compatibility",publish:!0,lastmod:"2024-02-04T00:00:00.000Z",date:"2024-02-04T00:00:00.000Z",aliases:null,tags:["status/seedling","topic/typescript"],readTime:3,internalLinks:["/notes/structural-branded-types-nominal"],flashcards:[]};function ks(h,a,r){return h.$$set=o=>{r(0,a=S(S({},a),z(o)))},a=z(a),[a]}class Ds extends ls{constructor(a){super(),ns(this,a,ks,ds,es,{})}}export{Ds as default,K as metadata};
