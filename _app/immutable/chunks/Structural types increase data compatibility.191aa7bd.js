import{s as X,C as H,a3 as P,f as m,a as d,a4 as j,g as v,u as f,c as y,a5 as q,i as o,d as p,A as z}from"./scheduler.5beeadad.js";import{S as K,i as Q,b as N,d as V,m as Y,a as Z,t as G,e as J}from"./index.bfd99307.js";import{g as W,a as B}from"./spread.8a54911c.js";import{M as ss}from"./MDSveXNoteLayout.ec8ae6b7.js";import{T as es}from"./Table.986747fa.js";function ts(u){let e,i="<tr><th></th> <th>Nominal</th> <th>Structural</th></tr>",r,l,a="<tr><td>Languages</td> <td>C, C++, Java, C#</td> <td>TypeScript, Go</td></tr> <tr><td>Type compatibility requirements</td> <td>Structure and name</td> <td>Structure</td></tr> <tr><td>Specificity</td> <td>Strict</td> <td>Flexible</td></tr>";return{c(){e=m("thead"),e.innerHTML=i,r=d(),l=m("tbody"),l.innerHTML=a},l(t){e=v(t,"THEAD",{["data-svelte-h"]:!0}),f(e)!=="svelte-rsxkvl"&&(e.innerHTML=i),r=y(t),l=v(t,"TBODY",{["data-svelte-h"]:!0}),f(l)!=="svelte-1m6m8v6"&&(l.innerHTML=a)},m(t,c){o(t,e,c),o(t,r,c),o(t,l,c)},p:z,d(t){t&&(p(e),p(r),p(l))}}}function as(u){let e,i="Typescript uses an approach to types called “structural typing”. Structural types are compatible if they share the same structure: the same named members and those members have the same types. This differs from languages such as C &amp; C++ which use an approach called “nominal typing.” Nominal types are only equivalent if they share the same structure <strong>and name</strong>. Here’s a quick reference:",r,l,a,t,c="I find it easiest to understand how structural types work with code examples:",x,g,O=`<pre class="shiki" style="background-color: #ffffff; color: #24292f" ts="true"><div class="language-id">ts</div><div class='code-container'><code><div class='line'><span style="color: #CF222E">type</span><span style="color: #24292F"> </span><span style="color: #953800">A</span><span style="color: #24292F"> </span><span style="color: #CF222E">=</span><span style="color: #24292F"> &#123; </span><span style="color: #953800">a</span><span style="color: #CF222E">:</span><span style="color: #24292F"> </span><span style="color: #0550AE">number</span><span style="color: #24292F"> &#125;;</span></div><div class='line'><span style="color: #CF222E">type</span><span style="color: #24292F"> </span><span style="color: #953800">B</span><span style="color: #24292F"> </span><span style="color: #CF222E">=</span><span style="color: #24292F"> &#123; </span><span style="color: #953800">a</span><span style="color: #CF222E">:</span><span style="color: #24292F"> </span><span style="color: #0550AE">number</span><span style="color: #24292F">, </span><span style="color: #953800">b</span><span style="color: #CF222E">:</span><span style="color: #24292F"> </span><span style="color: #0550AE">string</span><span style="color: #24292F"> &#125;;</span></div><div class='line'></div><div class='line'><span style="color: #6E7781">// &#96;a1&#96; is explicitly typed as an &#96;A&#96; object</span></div><div class='line'><span style="color: #CF222E">let</span><span style="color: #24292F"> a1</span><span style="color: #CF222E">:</span><span style="color: #24292F"> </span><span style="color: #953800">A</span><span style="color: #24292F"> </span><span style="color: #CF222E">=</span><span style="color: #24292F"> &#123; a: </span><span style="color: #0550AE">123</span><span style="color: #24292F"> &#125;;</span></div><div class='line'><span style="color: #6E7781">// &#96;a2&#96; is not explicitly typed as &#96;A&#96;...</span></div><div class='line'><span style="color: #CF222E">let</span><span style="color: #24292F"> a2 </span><span style="color: #CF222E">=</span><span style="color: #24292F"> &#123; a: </span><span style="color: #0550AE">321</span><span style="color: #24292F"> &#125;;</span></div><div class='line'><span style="color: #6E7781">// But its structure matches,</span></div><div class='line'><span style="color: #6E7781">// so it can be assigned to a type &#96;A&#96; object</span></div><div class='line'><span style="color: #24292F">a1 </span><span style="color: #CF222E">=</span><span style="color: #24292F"> a2; </span><span style="color: #6E7781">// Valid</span></div><div class='line'></div><div class='line'><span style="color: #6E7781">// &#96;b&#96; is explicitly typed as a &#96;B&#96; object</span></div><div class='line'><span style="color: #CF222E">let</span><span style="color: #24292F"> b</span><span style="color: #CF222E">:</span><span style="color: #24292F"> </span><span style="color: #953800">B</span><span style="color: #24292F"> </span><span style="color: #CF222E">=</span><span style="color: #24292F"> &#123;a: </span><span style="color: #0550AE">135</span><span style="color: #24292F">, b: </span><span style="color: #0A3069">"abc"</span><span style="color: #24292F">&#125;;</span></div><div class='line'><span style="color: #6E7781">// &#96;b&#96; can be assigned to an &#96;A&#96; object </span></div><div class='line'><span style="color: #6E7781">// because it is a superset of the structure of A</span></div><div class='line'><span style="color: #24292F">a2 </span><span style="color: #CF222E">=</span><span style="color: #24292F"> b; </span><span style="color: #6E7781">// Valid</span></div></code></div></pre>`,C,h,L="This approach is really convenient on the web where it’s common for data to come from external APIs; they may change the data provided. Structural typing makes it easy to handle extra data. In the <code>a2 = b</code> example above, the extra data on <code>b</code> is “sliced” off, narrowing it to an <code>A</code> object. The extra field on <code>B</code> doesn’t cause any issues! This makes it easy to opt-in to using additional data on a type when I’m ready, and to continue working until then.",w,F,S="TypeScript type compatibility can <em>reduce clarity</em> that a developer could otherwise provide using a named type. This might be an issue when trying to distinguish between <em>structurally</em> equivalent types that are <em>nominally</em> different. As an example, consider a <code>UserID</code> and <code>PostID</code> that are both represented as strings:",$,E,R=`<pre class="shiki twoslash lsp" style="background-color: #ffffff; color: #24292f" ts="true"><div class="language-id">ts</div><div class='code-container'><code><div class='line dim'><span style="color: #CF222E">type</span><span style="color: #24292F"> </span><span style="color: #953800"><data-lsp lsp='type UserID = string' >UserID</data-lsp></span><span style="color: #24292F"> </span><span style="color: #CF222E">=</span><span style="color: #24292F"> </span><span style="color: #0550AE">string</span><span style="color: #24292F">;</span></div><div class='line dim'><span style="color: #CF222E">type</span><span style="color: #24292F"> </span><span style="color: #953800"><data-lsp lsp='type PostID = string' >PostID</data-lsp></span><span style="color: #24292F"> </span><span style="color: #CF222E">=</span><span style="color: #24292F"> </span><span style="color: #0550AE">string</span><span style="color: #24292F">;</span></div><div class='line dim'>&nbsp;</div><div class='line dim'><span style="color: #CF222E">let</span><span style="color: #24292F"> <data-lsp lsp='let user: string' >user</data-lsp></span><span style="color: #CF222E">:</span><span style="color: #24292F"> </span><span style="color: #953800"><data-lsp lsp='type UserID = string' >UserID</data-lsp></span><span style="color: #24292F"> </span><span style="color: #CF222E">=</span><span style="color: #24292F"> </span><span style="color: #0A3069">"allan"</span><span style="color: #24292F">;</span></div><div class='line highlight'><span style="color: #CF222E">let</span><span style="color: #24292F"> <data-lsp lsp='let post: string' >post</data-lsp></span><span style="color: #CF222E">:</span><span style="color: #24292F"> </span><span style="color: #953800"><data-lsp lsp='type PostID = string' >PostID</data-lsp></span><span style="color: #24292F"> </span><span style="color: #CF222E">=</span><span style="color: #24292F"> <data-lsp lsp='let user: string' >user</data-lsp>;</span></div></code></div></pre>`,T,b,I="These are two different <em>named</em> types but because they are <em>structurally</em> identical TypeScript will allow you to assign a <code>UserID</code> value to a <code>PostID</code> object. Yikes! Compatibility makes problems like this possible.",A,_,M='Fortunately, it can be solved in TypeScript. <a href="/notes/Type%20branding%20removes%20structural%20type%20compatibility/">Type branding removes structural type compatibility</a>, and can be used to prevent this type of problem.',k;return l=new es({props:{$$slots:{default:[ts]},$$scope:{ctx:u}}}),{c(){e=m("p"),e.innerHTML=i,r=d(),N(l.$$.fragment),a=d(),t=m("p"),t.textContent=c,x=d(),g=new j(!1),C=d(),h=m("p"),h.innerHTML=L,w=d(),F=m("p"),F.innerHTML=S,$=d(),E=new j(!1),T=d(),b=m("p"),b.innerHTML=I,A=d(),_=m("p"),_.innerHTML=M,this.h()},l(s){e=v(s,"P",{["data-svelte-h"]:!0}),f(e)!=="svelte-2kmkxw"&&(e.innerHTML=i),r=y(s),V(l.$$.fragment,s),a=y(s),t=v(s,"P",{["data-svelte-h"]:!0}),f(t)!=="svelte-44hwdv"&&(t.textContent=c),x=y(s),g=q(s,!1),C=y(s),h=v(s,"P",{["data-svelte-h"]:!0}),f(h)!=="svelte-1lw6j2q"&&(h.innerHTML=L),w=y(s),F=v(s,"P",{["data-svelte-h"]:!0}),f(F)!=="svelte-rhottr"&&(F.innerHTML=S),$=y(s),E=q(s,!1),T=y(s),b=v(s,"P",{["data-svelte-h"]:!0}),f(b)!=="svelte-5ewpk0"&&(b.innerHTML=I),A=y(s),_=v(s,"P",{["data-svelte-h"]:!0}),f(_)!=="svelte-1yxotue"&&(_.innerHTML=M),this.h()},h(){g.a=C,E.a=T},m(s,n){o(s,e,n),o(s,r,n),Y(l,s,n),o(s,a,n),o(s,t,n),o(s,x,n),g.m(O,s,n),o(s,C,n),o(s,h,n),o(s,w,n),o(s,F,n),o(s,$,n),E.m(R,s,n),o(s,T,n),o(s,b,n),o(s,A,n),o(s,_,n),k=!0},p(s,n){const D={};n&2&&(D.$$scope={dirty:n,ctx:s}),l.$set(D)},i(s){k||(Z(l.$$.fragment,s),k=!0)},o(s){G(l.$$.fragment,s),k=!1},d(s){s&&(p(e),p(r),p(a),p(t),p(x),g.d(),p(C),p(h),p(w),p(F),p($),E.d(),p(T),p(b),p(A),p(_)),J(l,s)}}}function ls(u){let e,i;const r=[u[0],U];let l={$$slots:{default:[as]},$$scope:{ctx:u}};for(let a=0;a<r.length;a+=1)l=H(l,r[a]);return e=new ss({props:l}),{c(){N(e.$$.fragment)},l(a){V(e.$$.fragment,a)},m(a,t){Y(e,a,t),i=!0},p(a,[t]){const c=t&1?W(r,[t&1&&B(a[0]),t&0&&B(U)]):{};t&2&&(c.$$scope={dirty:t,ctx:a}),e.$set(c)},i(a){i||(Z(e.$$.fragment,a),i=!0)},o(a){G(e.$$.fragment,a),i=!1},d(a){J(e,a)}}}const U={title:"Structural types increase data compatibility",description:"Structural types are only concerned with the shape of data, rather than the names of types. This makes data types more compatible.",slug:"structural-types-increase-compatibility",publish:!0,lastmod:"2024-02-04T00:00:00.000Z",date:"2024-02-04T00:00:00.000Z",aliases:null,tags:["status/seedling","topic/typescript"],timeToRead:2,internalLinks:["/notes/Type%20branding%20removes%20structural%20type%20compatibility/"],flashcards:[]};function ns(u,e,i){return u.$$set=r=>{i(0,e=H(H({},e),P(r)))},e=P(e),[e]}class ds extends K{constructor(e){super(),Q(this,e,ns,ls,X,{})}}export{ds as default,U as metadata};
