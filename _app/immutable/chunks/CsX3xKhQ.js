import{t as s,a as r}from"./Bj2ZHtgv.js";import"./DBHxkW5N.js";import{R as l}from"./fxLts69-.js";import{l as d,s as p}from"./BMf7CqPI.js";import{M as m}from"./CgiG3LfS.js";const e={title:"devlog 11",description:"Learning new technologies, vim, and neovim!",slug:"devlog/11",publish:!0,lastmod:"2024-07-09T00:00:00.000Z",date:"2024-07-28T00:00:00.000Z",aliases:null,tags:["status/seedling"],readTime:3,internalLinks:["/notes/use-neovim"],flashcards:[]},{title:y,description:b,slug:k,publish:I,lastmod:x,date:T,aliases:$,tags:L,readTime:A,internalLinks:z,flashcards:D}=e;var h=s('<h2 id="building-an-ai-improv-skit-generator"><a aria-hidden="true" tabindex="-1" href="#building-an-ai-improv-skit-generator"><span class="icon icon-link"></span></a><a href="#building-an-ai-improv-skit-generator" aria-hidden="true" tabindex="-1"><span class="icon icon-link"></span></a>Building an AI improv skit generator</h2> <p>I find that over time I encounter a number of technologies I’m interested in trying out. Often, it’s not easy to do so in an existing project because something else is already in use that fills a similar role. A couple recent examples for me are:</p> <ul><li><a href="https://deno.land" rel="nofollow">Deno</a>, a <em>JavaScript</em>/<em>TypeScript</em> runtime and package manager</li> <li><a href="https://orm.drizzle.team/docs/overview" rel="nofollow">Drizzle ORM</a>, a <em>TypeScript</em> Object-Relational Mapping (ORM) tool with great performance that has syntax similar to SQL</li></ul> <p>Additionally, I learned about <a href="https://www.langchain.com/" rel="nofollow">LangChain and LangGraph</a> recently at <a href="https://cascadiajs.com/2024/" rel="nofollow">CascadiaJS</a> and was pretty excited to try my hand at building something with it. I had no need for it in my existing projects, though. Time to start a new project!</p> <p>I decided to use LangGraph to build an AI agent that orchestrates an AI-powered improv show. It runs on a Deno server that exposes a single endpoint that allows users to provide a skit topic, and then generates a few rounds of banter between some AI comedians on the topic. As the agent completes steps in its task, the progress is saved as a <code>Checkpoint</code> which I save in a database using Drizzle.</p> <p>The project isn’t deployed anywhere, but you can check out the code <a href="https://github.com/Masstronaut/langchain-endpoint" rel="nofollow">on my GitHub</a>. If you want a little improv skit of your own, the repo has some setup instructions in the readme.</p> <h2 id="learning-neovim"><a aria-hidden="true" tabindex="-1" href="#learning-neovim"><span class="icon icon-link"></span></a><a href="#learning-neovim" aria-hidden="true" tabindex="-1"><span class="icon icon-link"></span></a>Learning Neovim</h2> <p>On Sunday I was still in the learning mood, but didn’t feel like doing any serious programming work. So instead I decided to cave to some peer pressure (and YouTube algorithm recommendations) and <a href="https://www.youtube.com/playlist?list=PLsz00TDipIffreIaUNk64KxTIkQaGguqn" rel="nofollow">learn how to setup Neovim as an IDE</a>. The experience brought back fond memories of my time as an Arch Linux user, and now <a href="/notes/use-neovim">I use Neovim btw</a>. I was surprised to find that getting to a similar level of productivity with vim vs without takes very little time, and the rest is upside. Plus, editing text is <em>substantially</em> more fun using vim. As someone who spends most of the day typing, I believe it’s worth learning just to make the day more fun!</p>',1);function S(a,t){const i=d(t,["children","$$slots","$$events","$$legacy"]);m(a,p(()=>i,e,{children:(n,c)=>{var o=h();l(14),r(n,o)},$$slots:{default:!0}}))}export{S as default,e as metadata};
