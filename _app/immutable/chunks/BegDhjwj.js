import{t as n,a as r}from"./Bj2ZHtgv.js";import"./DBHxkW5N.js";import{R as d}from"./fxLts69-.js";import{l as c,s as l}from"./BMf7CqPI.js";import{M as m}from"./CQtT7V7I.js";const e={title:"Make API misuse hard",description:"Being hard to misuse is an underrated characteristic of exceptional APIs, especially when the possibility needs to be exposed to the client for advanced scenarios.",slug:"notes/make-api-misuse-hard",publish:!0,lastmod:"2024-02-13T00:00:00.000Z",date:"2024-02-14T00:00:00.000Z",aliases:null,tags:["status/seedling","topic/softwaredev"],readTime:4,internalLinks:[],flashcards:[]},{title:w,description:I,slug:v,publish:k,lastmod:A,date:P,aliases:_,tags:T,readTime:x,internalLinks:$,flashcards:q}=e;var p=n('<p>APIs are a tool used to accomplish a task. In almost every case, there exists one or a few correct ways to do it, and many incorrect ways. A <em>great</em> API makes it much more difficult to do it wrong.</p> <h2 id="cs-unique_ptr-an-api-great-at-avoiding-misuse"><a aria-hidden="true" tabindex="-1" href="#cs-unique_ptr-an-api-great-at-avoiding-misuse"><span class="icon icon-link"></span></a><a href="#cs-unique_ptr-an-api-great-at-avoiding-misuse" aria-hidden="true" tabindex="-1"><span class="icon icon-link"></span></a>C++’s <code>unique_ptr</code>, an API great at avoiding misuse</h2> <p>My favorite example of this principle is the C++ standard library’s <code>unique_ptr&lt;T&gt;</code>. In C++, memory needs to be manually allocated and freed by the programmer; it’s extremely hard to get right, and every C++ programmer has struggled with issues that arise from doing it wrong. The <code>unique_ptr&lt;T&gt;</code> addresses this by taking sole custody of a memory block and freeing the memory when it leaves scope or is destructed. If you use a <code>unique_ptr&lt;T&gt;</code> to manage all the memory you allocate, you will not have a memory leak. It works correctly by default. Great API design!</p> <p>Sometimes there is a legitimate need to access the memory address of your data directly, which can be done using <code>unique_ptr&lt;T&gt;</code>‘s <code>get()</code> or <code>release()</code> method. This opens up a variety of ways to shoot yourself in the foot by managing memory incorrectly. It’s still possible to shoot yourself in the foot, but doing so requires manually disabling the safety. It’s harder to use incorrectly. Great API design.</p> <h2 id="unity-components-an-easily-misused-api"><a aria-hidden="true" tabindex="-1" href="#unity-components-an-easily-misused-api"><span class="icon icon-link"></span></a><a href="#unity-components-an-easily-misused-api" aria-hidden="true" tabindex="-1"><span class="icon icon-link"></span></a>Unity components, an easily misused API</h2> <p>Unity is a popular game engine that uses a component-centric API. Everything in the game is created as a game object, and an object’s behavior is determined by which components are added to it. A component encapsulates both logic and the data it depends on. Often data is needed by multiple behaviors; the most common example is rendering and physics both needing to know where an object is. Components can read and write to each others’ data via the parent game object: <code>this.parent.get&lt;Component&gt;()</code>.</p> <p>This API is simple, straightforward, and easy to use. Upon realizing you need to more data for a behavior, it makes it easy to just grab the data and get on with it. Unfortunately, it’s a terribly slow API for games, requiring at least two different cache misses - the parent, and the other component. Used sparingly this isn’t a problem, but used in many components on many game objects, it offers a convenient way to make every part of the game run slowly. Furthermore, the way the API is designed makes it impossible to avoid the cache misses; it’s performance dead-end that can’t be optimized! This API makes it easy to ruin a game’s performance; it’s a poor API design.</p> <p>I found the idea of APIs limiting performance of game engines so fascinating I did a <a href="https://youtu.be/W3ViIBnTTKA" rel="nofollow">C++Now presentation on the topic</a>. In the talk, I introduce another API design which is still simple to use, makes it easy to introduce additional data in the future, and keeps the backing implementation possible to optimize in a variety of ways, including with safe concurrency. It’s worth a watch if you build performance-sensitive libraries.</p>',1);function C(t,a){const i=c(a,["children","$$slots","$$events","$$legacy"]);m(t,l(()=>i,e,{children:(s,h)=>{var o=p();d(14),r(s,o)},$$slots:{default:!0}}))}export{C as default,e as metadata};
