import"./Bzak7iHL.js";import"./DvJAWxb3.js";import{f,s as n,a as w,T as r,b as s,V as o}from"./BxJAsQqh.js";import{l as b,s as k}from"./DRDuvXTo.js";import{M as v}from"./BOLgEJI6.js";import{H as d}from"./MijRK8hC.js";const l={title:"devlog 15: inline comment rendering",description:"Imagine being able to see word processor style comments, inline, on any website! Turns out it's not small feat...",slug:"devlog/15",publish:!0,lastmod:"2025-11-03T00:00:00.000Z",date:"2025-11-03T00:00:00.000Z",aliases:[null],tags:["status/seedling"],readTime:4,internalLinks:[],flashcards:[]},{title:q,description:H,slug:L,publish:M,lastmod:P,date:S,aliases:z,tags:O,readTime:R,internalLinks:Z,flashcards:j}=l;var y=f('<p>I’ve made exciting progress on <a href="https://docduck.dev" rel="nofollow">Doc Duck</a>: it now has the ability to show inline comments on ranges of text. This may not sound like a big deal, but in Sam’s words, <a href="https://bsky.app/profile/samwho.dev/post/3ls7ydfxux22p" rel="nofollow">that turns out to be Really Fucking Hard</a>. Sam’s case was actually much easier than mine, too; it was scoped to his own site. Doc Duck needs to be able to do it on <em>any</em> site.</p> <!> <p>One of the hardest parts of this problem is <em>finding the range of the document that was commented on</em>. Documents tend to change over time, and Doc Duck’s code needs to work on any site, which means a wide range of possible ways the page content exists. This means many edge cases which all need to be handled. The Doc Duck widget uses 5 heuristics to try to find the range with feedback on it.</p> <p>I also employs a handful of other techniques that attempt to manage changes in document structure between when feedback was provided and when a Doc Duck user is trying to view it. For example, when a user selects text whitespace gets collapsed, but when traversing the DOM tree it doesn’t. I had to build a custom utility for collapsing whitespace.</p> <p>I’ve still got a lot more work to do here to provide a good experience when the original text has changed, but I’m happy with where it’s at currently as a v1.</p> <!> <p>Another major challenge with Doc Duck’s inline comments rendering is that it’s done on third party sites. Feedback should only be rendered for Doc Duck users who are authorized to see feedback on that site. This is difficult because it would be insecure for a user signed in on <a href="https://docduck.dev" rel="nofollow">docduck.dev</a> to send their auth cookie on requests to the doc duck servers that come from other web pages.</p> <p>The solution I’ve come up with here is that users must request to see feedback inline on a page from within the Doc Duck dashboard. They get a 1-time token that the widget can use to load feedback for them on a single page. It’s extremely secure, works reliably, and the experience is seamless.</p> <p>I’m excited to get this in the hands of customers as it’s a massive improvement over existing solutions.</p>',1);function A(c,h){const u=b(h,["children","$$slots","$$events","$$legacy"]);v(c,k(()=>u,()=>l,{children:(p,$)=>{var a=y(),i=n(w(a),2);d(i,{id:"finding-a-previous-selection-in-a-document",children:(e,g)=>{o();var t=r("Finding a previous selection in a document");s(e,t)},$$slots:{default:!0}});var m=n(i,8);d(m,{id:"rendering-feedback-on-a-3rd-party-site",children:(e,g)=>{o();var t=r("Rendering feedback on a 3rd-party site");s(e,t)},$$slots:{default:!0}}),o(6),s(p,a)},$$slots:{default:!0}}))}export{A as default,l as metadata};
